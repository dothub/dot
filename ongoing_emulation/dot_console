#!/bin/bash

# This file is part of DOT.
#
#     DOT is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     DOT is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with DOT.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright 2011-2013 dothub.org
#

#
#  dot_access
#
#  Created on: 2014-02-18
#      Author: Arup Raton Roy (ar3roy@uwaterloo.ca)



USER_NAME="dot"
VM_LIST=()


#Function readMapping retrieves the username of the DOT node
#and corresping host of the provisioned VMs
#Takes the mapping file name as parameter1
function readMapping {

	flag=0
	index=0	
	#reading the mapping file
	while read line
	do
	
		if [ "$flag" -eq 0 ]; then
			#Reading the user name 
			USER_NAME=$line			
			flag=$((flag+1))
			continue
		fi
	VM_LIST[$index]="$line"
	index=$((index+1))

	
	done < $1

} 


switch1_DN=0
switch2_DN=0
switch1_port=0
switch2_port=0

function readLinks {
#Finding the DOT nodes of the switches
   switch1_DN=`awk '{if($1=="'"$1"'"){print $2}}' switch_mapping`
   switch2_DN=`awk '{if($1=="'"$2"'"){print $2}}' switch_mapping`
   switch1_port=`awk '
                    {
                    if(($1=="'"$1"'" && $3=="'"$2"'")||($1=="'"$2"'"&& $3=="'"$1"'"))
                    {
                        if($1=="'"$1"'")
                            print $2;
                        else
                            print $4;
                    }    
                    }' link_mapping`

    switch2_port=`awk '
                    {
                    if(($1=="'"$1"'" && $3=="'"$2"'")||($1=="'"$2"'"&& $3=="'"$1"'"))
                    {
                        if($1=="'"$2"'")
                            print $2;
                        else
                            print $4;
                    }    
                    }' link_mapping`



}

#Reading the mapping file
readMapping mapping

proceessIDs=()
processIndex=0
connectedVM=0
while :
do 

	echo -ne "dot>"
	
	#Reading the command
	read input
		
	#Parsing the input for input and command
	command=`echo $input| cut -f1 -d' '`
	parameter1=`echo $input| cut -f2 -d' '`
    parameter2=`echo $input| cut -f3 -d' '`	
	
	case "$command" in
		("connect") 
			#Here, parameter1 is the name of the VM 
			echo "Connecting $parameter1"
			
			foundFlag=0

			#Retrieving the the VM
			for mapping in "${VM_LIST[@]}"
			do
			
				#Finding a match
				VM_NAME=`echo "$mapping"| grep $parameter1| cut -f1 -d' '`
			
				if [ "$VM_NAME" = "$parameter1" ]; then
				
					foundFlag=1
					
					#Retrieving the ip address of the host
					IP_ADDRESS=`echo "$mapping"| grep $parameter1 | cut -f2 -d' '`
		 				
					
					#Connecting the VM
                        		virt-viewer -c qemu+ssh://$USER_NAME@$IP_ADDRESS/system $parameter1 &>/dev/null &  
                        
                       			#Storing the process id
                        		processIDs[$processIndex]="$parameter1 $! active"
                        		processIndex=$((processIndex+1))
					
		            
                    connectedVM=$((connectedVM+1))

        			break
								
				fi
			done 

			#No VM is found
                        if [ "$foundFlag" -eq 0 ]; then
                                echo "$parameter1 is not running"
                        fi			
			;;

		("disconnect") 
			#Here, the parameter1 is the name of the VM
						
			#Retrieving the proeces id of the VM
			retrieveFlag=0
			for index in "${!processIDs[@]}"
			do
				status=`echo ${processIDs[$index]}| grep $parameter1| cut -f3 -d' '`
				
				
				if [ "$status" = "active" ]; then
					#Found an active VM 
					retrieveFlag=1
					echo "Disconnecting $parameter1"
					
					#retrieving the process id
					process_id=`echo ${processIDs[$index]}|  cut -f2 -d' '`
					
					#Killing the process
					kill -9 $process_id

					#Removing the VM from the list of active VMs
					unset processIDs[$index]
					
                    connectedVM=$((connectedVM-1))

					break
				fi

			done
			
			#No VM is found
			if [ "$retrieveFlag" -eq 0 ]; then
				echo "$parameter1 is not connected"
			fi
			
			;;

		("quit")
            if [ ! "$connectedVM" = 0 ]; then

			    read -r -p "Do you want to disconnect all VMs? [Y/n]" response
			    response=${response,,} # tolower
			
			    if [[ $response =~ ^(yes|y| ) ]]; then
				    for process in "${processIDs[@]}"
				    do
					    status=`echo $process| cut -f3 -d' '`
                                            VM=`echo $process| cut -f1 -d' '`        

					    if [ "$status" = "active" ]; then
						    #Found an active VM 
						    echo "Disconnecting $VM"

						    #retrieving the process id
						    process_id=`echo $process|  cut -f2 -d' '`

						    #Killing the process
						    kill -9 $process_id

                        fi

				    done
			
			    fi
            fi

		    echo "Exiting...."
			exit
			;;
        
        ("clean")
            case "$parameter1" in
                ("all")
                    read -r -p "Do you want to destroy all VMs and VSs? [Y/n]" response
                    response=${response,,} # tolower
    
                    if [[ $response =~ ^(yes|y| ) ]]; then
 
                        for machine in `cat mapping | grep h | awk '{print $2}'| sort |uniq`
                        do
                            echo "Cleaning $machine"
                            scp clean_machine.sh $USER_NAME@$machine:~  
                            ssh $USER_NAME@$machine "sudo ./clean_machine.sh"
                            ssh $USER_NAME@$machine "rm ~/clean_machine.sh"
                        
                        done
                        #Cleaning all clone images
                        rm ../resources/images/clone_*.qcow2
                        echo "$USER_NAME" > mapping
                        exit 
                    fi 
                ;;
                (*)
                    echo "To clean DOT: clean all"
            esac
            ;;
        ("attach")
                #Finding the DOT nodes of the switches
                readLinks $parameter1 $parameter2
                ssh $USER_NAME@$switch1_DN "sudo ovs-vsctl add-port topo${parameter1:1} $switch1_port"
                ssh $USER_NAME@$switch2_DN "sudo ovs-vsctl add-port topo${parameter2:1} $switch2_port"
            ;;

        ("detach")
                readLinks $parameter1 $parameter2
                ssh $USER_NAME@$switch1_DN "sudo ovs-vsctl del-port topo${parameter1:1} $switch1_port"
                ssh $USER_NAME@$switch2_DN "sudo ovs-vsctl del-port topo${parameter2:1} $switch2_port"
           ;;

        ("ping")
                echo "pinging $parameter2"
                image_id=`grep $parameter1 mapping|cut -f3 -d' '`
                image_uname=`head -$image_id image_username| tail -1|cut -f2 -d' '`
                ssh -i key $image_uname@$parameter1 "ping $parameter2" 
            ;;
        ("pingAll")
                hosts=(`awk '{if(NR!=1){print $1}}' mapping`)
                numberOfHosts=${#hosts[@]}
                for (( i=0; i<=$numberOfHosts-2; i++ ))
                do
                    for (( j=$i+1; j<=$numberOfHosts-1; j++ ))
                    do 
                        echo "Pinging ${hosts[$i]}->${hosts[$j]}"
                        image_id=`grep ${hosts[$i]} mapping|cut -f3 -d' '`
                        image_uname=`head -$image_id image_username| tail -1|cut -f2 -d' '`
                        ssh -i key $image_uname@${hosts[$i]} "ping ${hosts[$j]} -c 4"
                        echo ""
                    done
                done
            ;;

         ("run")
                case "$parameter1" in
                    ("-b")
                        #Running in background
                        case "$parameter2" in
                            ("-s")
                                host=`echo $input| cut -f4 -d' '`
                                image_id=`grep $host mapping|cut -f3 -d' '`
                                image_uname=`head -$image_id image_username| tail -1|cut -f2 -d' '`
                                scriptWithPath=`echo $input| awk '{$1="";$2="";$3="";$4="";print $0}'` 
                                scriptName=`basename $scriptWithPath`
                                scp -i key $scriptWithPath $image_uname@$host: >/dev/null
                                ssh -f -i key $image_uname@$host "./$scriptName"
                        
                            ;;
                            
                            (*)
                                host=$parameter2
                                image_id=`grep $host mapping|cut -f3 -d' '`
                                image_uname=`head -$image_id image_username| tail -1|cut -f2 -d' '`
                                runCommand=`echo $input| awk '{$1="";$2="";$3=""; print $0}'`
                                ssh -f -i key $image_uname@$host "$runCommand"
     
                            ;;
                        esac
                    ;;
                   ("-s")
                        host=$parameter2
                        image_id=`grep $host mapping|cut -f3 -d' '`
                        image_uname=`head -$image_id image_username| tail -1|cut -f2 -d' '`
                        scriptWithPath=`echo $input| awk '{$1="";$2="";$3=""; print $0}'` 
                        scriptName=`basename $scriptWithPath`
                        echo "$scriptName"
                        scp -i key $scriptWithPath $image_uname@$host: >/dev/null
                        ssh -i key $image_uname@$host "./$scriptName"
                    ;;
                    (*)
                        echo "command front"
                        host=$parameter1
                        image_id=`grep $host mapping|cut -f3 -d' '`
                        image_uname=`head -$image_id image_username| tail -1|cut -f2 -d' '`
                        runCommand=`echo $input| awk '{$1="";$2=""; print $0}'`
                        ssh -i key $image_uname@$host "$runCommand"
                    ;;
                esac
            ;;
    	(*) 
			echo "For connecting to VM: connect h#"
			echo "For disconnecting a VM: disconnect h#"
            echo "For detaching a link: detach s# s#"
            echo "For reattaching a link: attach s# s#"
            echo "Ping: ping h# h#"
            echo "For sending ping between all pair of hosts: PingAll"
            echo "For running command in a host: run [-b] [-s] command/scriptfile"
            echo "For cleaning DOT: clean all"
			echo "To exit: quit"
			;;

	esac
done
